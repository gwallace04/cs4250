\documentclass[letterpaper, 11pt]{article}
%\usepackage[hmargin = 1in, vmargin = 1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{mathrsfs}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\setlength{\headheight}{14pt}
\usepackage{fancyhdr}
\pagestyle{fancy}
\rhead{Gabriel Wallace}
\lhead{Comp Sci 4250}

\newcommand{\card}{\text{Card}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}

\newcommand{\inv}{^{-1}}
\newcommand{\abs}[1]{\lvert #1 \rvert}
\newcommand{\hwnumber}[1]{\medskip \noindent\textbf{#1.} \smallskip}
\newcommand{\hwnumbersec}[3]{\medskip \noindent\textbf{#1.} Chapter #2 #3
\newline\noindent\textbf{Q:}}
\newcommand{\A}{\noindent\textbf{A:} }
\newcommand{\Mod}[1]{\ \mathrm{mod}\ #1}
\newcommand{\Alg}[1]{\medskip \noindent\textbf{ALGORITHM} \( #1 \)} 
\newcommand{\To}{\textbf{ to }}

\begin{document}
\begin{center}
	{\LARGE Homework 1}\\
\end{center}

\hwnumbersec{1}{1}{RQ \#1}
Why is it useful for a programmer to have some background in language design,
even though he or she may never actually design a programming language?

\A The reasons given in the book are: 
\begin{itemize}
\item Increased capacity to express ideas
\item Improved background for choosing appropriate languages
\item Increased ability to learn new languages
\item Better understanding of the significance of implementation
\item Better use of languages that are already known
\item Overall advancement of computing
\end{itemize}

In essence, studying how programming languages work gives the programmer more
knowledge, which in turn makes for a better programmer. When all you have is a
hammer, everything looks like a nail. By studying language design, programmers
are able to expand their toolkit. Sometimes, a hammer is the perfect tool for
the job, but it oftentimes isn't. Furthermore, computer science and programming
are a relatively new discipline, meaning that change happens all the time. The
hammer (i.e the programming language or data structure) you are using today
could very well be obsolete by tomorrow. This is less of a problem if (a) you
have many other tools to use and (b) understand the fundamentals of language
design and thus can pick up the new tools instead.  

\hwnumbersec{2}{1}{RQ \#16}
Why is readability important to writability?

\A Writing requires reading, that is when writing a program, the programmer will
have to read the program many times. In addition, a lot of software development
today is focused on maintaining existing code rather than writing new code from
scratch. If the programming language is highly readable, it will make writing
and revising the code much easier.  

\hwnumbersec{3}{1}{PS \#10}
What are the arguments for writing efficient programs even though hardware is
relatively inexpensive?

\A There are two main arguments for efficient programs despite cheap hardware.
The first is that while hardware can be inexpensive (and continues to become
less expensive), it will never be free. Less efficient programs can be orders of
magnitude slower and why take write code that is less efficient than necessary?
For example, an implementation of a sorting algorithm using bubble sort will
take much longer than using quick sort or merge sort for most data sets, and
this difference grows larger as the size of the input grows. 

The second argument is that while hardware is inexpensive, the programmer's time
may not be. Efficient programs will run faster and will therefore take up less
of the programmer's and the end user's time. Also, efficient code is more
likely to be readable and extensible, which makes it easier for the programmer
to maintain the code. 

\hwnumbersec{4}{2}{RQ \#5}
Why was the slowness of interpretation of programs acceptable in the early
1950s?

\A The computers at that time did not have hardware capable of storing floating
point numbers, and therefore all floating point calculations had to be done in
software. This was the largest limiting factor in program speed, so the cost of
interpretation was acceptable. 

\hwnumbersec{5}{2}{RQ \#20}
What missing language element of ALGOL 60 damaged its chances for widespread
use?

\A The missing element from ALGOL 60 was the lack of input and output streams,
which made the programs non-portable. 

\hwnumber{6}{2}{PS \#13}
What is the primary reason why PL/I became more widely used than ALGOL 68?

\A The primary reason is that PL/I had the support of a massive company, IBM.
This allowed them to have greater resources in designing the language and
compiler and had better marketing. Also, the goals were slightly different for
the two languages: PL/I was trying to be a general purpose language, while
ALGOL 68 was for scientific applications. The more use cases a language has, the
more likely it will be widespread. 

\end{document}
